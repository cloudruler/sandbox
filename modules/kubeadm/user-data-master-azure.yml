#cloud-config
ssh_authorized_keys:
    #brianmoore
    - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC+HxnuN1D7vtkxABtAxRizT2RrUha45M3qBABWKBJAEJqev9gUC0zRxAwW6Eh8lhfv9jKcnekMkOZNPrR/Bx5cuv0hACDxF4nb2trcFTK2IOuaGidk3zld71jQYDnpVes9BSqcMkn9nmx8Nl7p5KPt1foTSezdZq/neiOZ/vV5r8iPmSOwxigYFP2G70P2dMFTY+KyoWDk60WAjr2g6EHSdI4GgR6kghgMAcVuljnseDJVLmYn8I/B2FSXH7APtd0h6J673S8wPZuNzIEYzm/KEobBn0EpnhyqfOjN5VLdNOUGpXb/VPNXeKaB3KoOzEh20FkaVJmNXlN0WKC1hyCl brian@DESKTOP-SFIVOEU
package_upgrade: true
packages:
#Install packages needed to use the Kubernetes apt repository:
- apt-transport-https
- ca-certificates
- curl
write_files:
- path: /etc/environment
#Suppress Warning: apt-key output should not be parsed (stdout is not a terminal)
  content: |
    APT_KEY_DONT_WARN_ON_DANGEROUS_USAGE="1"
  append: true
#Configuration for containerd
- path: /etc/containerd/config.toml
  permissions: '0644'
  content: |
    version = 2
    root = "/var/lib/containerd"
    state = "/run/containerd"
    plugin_dir = ""
    disabled_plugins = []
    required_plugins = []
    oom_score = 0

    [grpc]
      address = "/run/containerd/containerd.sock"
      tcp_address = ""
      tcp_tls_cert = ""
      tcp_tls_key = ""
      uid = 0
      gid = 0
      max_recv_message_size = 16777216
      max_send_message_size = 16777216

    [ttrpc]
      address = ""
      uid = 0
      gid = 0

    [debug]
      address = ""
      uid = 0
      gid = 0
      level = ""

    [metrics]
      address = ""
      grpc_histogram = false

    [cgroup]
      path = ""

    [timeouts]
      "io.containerd.timeout.shim.cleanup" = "5s"
      "io.containerd.timeout.shim.load" = "5s"
      "io.containerd.timeout.shim.shutdown" = "3s"
      "io.containerd.timeout.task.state" = "2s"

    [plugins]
      [plugins."io.containerd.gc.v1.scheduler"]
        pause_threshold = 0.02
        deletion_threshold = 0
        mutation_threshold = 100
        schedule_delay = "0s"
        startup_delay = "100ms"
      [plugins."io.containerd.grpc.v1.cri"]
        disable_tcp_service = true
        stream_server_address = "127.0.0.1"
        stream_server_port = "0"
        stream_idle_timeout = "4h0m0s"
        enable_selinux = false
        selinux_category_range = 1024
        sandbox_image = "k8s.gcr.io/pause:3.2"
        stats_collect_period = 10
        systemd_cgroup = false
        enable_tls_streaming = false
        max_container_log_line_size = 16384
        disable_cgroup = false
        disable_apparmor = false
        restrict_oom_score_adj = false
        max_concurrent_downloads = 3
        disable_proc_mount = false
        unset_seccomp_profile = ""
        tolerate_missing_hugetlb_controller = true
        disable_hugetlb_controller = true
        ignore_image_defined_volumes = false
        [plugins."io.containerd.grpc.v1.cri".containerd]
          snapshotter = "overlayfs"
          default_runtime_name = "runc"
          no_pivot = false
          disable_snapshot_annotations = true
          discard_unpacked_layers = false
          [plugins."io.containerd.grpc.v1.cri".containerd.default_runtime]
            runtime_type = ""
            runtime_engine = ""
            runtime_root = ""
            privileged_without_host_devices = false
            base_runtime_spec = ""
          [plugins."io.containerd.grpc.v1.cri".containerd.untrusted_workload_runtime]
            runtime_type = ""
            runtime_engine = ""
            runtime_root = ""
            privileged_without_host_devices = false
            base_runtime_spec = ""
          [plugins."io.containerd.grpc.v1.cri".containerd.runtimes]
            [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]
              runtime_type = "io.containerd.runc.v2"
              runtime_engine = ""
              runtime_root = ""
              privileged_without_host_devices = false
              base_runtime_spec = ""
              [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]
                SystemdCgroup = true
        [plugins."io.containerd.grpc.v1.cri".cni]
          bin_dir = "/opt/cni/bin"
          conf_dir = "/etc/cni/net.d"
          max_conf_num = 1
          conf_template = ""
        [plugins."io.containerd.grpc.v1.cri".registry]
          [plugins."io.containerd.grpc.v1.cri".registry.mirrors]
            [plugins."io.containerd.grpc.v1.cri".registry.mirrors."docker.io"]
              endpoint = ["https://registry-1.docker.io"]
        [plugins."io.containerd.grpc.v1.cri".image_decryption]
          key_model = ""
        [plugins."io.containerd.grpc.v1.cri".x509_key_pair_streaming]
          tls_cert_file = ""
          tls_key_file = ""
      [plugins."io.containerd.internal.v1.opt"]
        path = "/opt/containerd"
      [plugins."io.containerd.internal.v1.restart"]
        interval = "10s"
      [plugins."io.containerd.metadata.v1.bolt"]
        content_sharing_policy = "shared"
      [plugins."io.containerd.monitor.v1.cgroups"]
        no_prometheus = false
      [plugins."io.containerd.runtime.v1.linux"]
        shim = "containerd-shim"
        runtime = "runc"
        runtime_root = ""
        no_shim = false
        shim_debug = false
      [plugins."io.containerd.runtime.v2.task"]
        platforms = ["linux/amd64"]
      [plugins."io.containerd.service.v1.diff-service"]
        default = ["walking"]
      [plugins."io.containerd.snapshotter.v1.devmapper"]
        root_path = ""
        pool_name = ""
        base_image_size = ""
        async_remove = false
# kubeadm config file
- path: /etc/kubeadm/kubeadm-config.yml
  permissions: '0644'
  content: |
%{ if node_type == "master" ~}
    apiVersion: kubeadm.k8s.io/v1beta2
    bootstrapTokens:
    - groups:
      - system:bootstrappers:kubeadm:default-node-token
      token: ${bootstrap_token}
      ttl: 24h0m0s
      usages:
      - signing
      - authentication
    kind: InitConfiguration
    nodeRegistration:
      criSocket: /run/containerd/containerd.sock
      taints:
      - effect: NoSchedule
        key: node-role.kubernetes.io/master
    ---
    apiVersion: kubeadm.k8s.io/v1beta2
    kind: ClusterConfiguration
    controlPlaneEndpoint: ${ api_server_name }
    networking:
      podSubnet: ${pod_cidr}
%{ else ~}
    apiVersion: kubeadm.k8s.io/v1beta2
    discovery:
      bootstrapToken:
        apiServerEndpoint: ${api_server_name}:6443
        token: ${bootstrap_token}
        unsafeSkipCAVerification: false
        caCertHashes:
        - ${discovery_token_ca_cert_hash}
      tlsBootstrapToken: ${bootstrap_token}
    kind: JoinConfiguration
    nodeRegistration:
      criSocket: /run/containerd/containerd.sock
%{ endif ~}
    ---
    apiVersion: kubelet.config.k8s.io/v1beta1
    kind: KubeletConfiguration
    cgroupDriver: systemd
#Make sure that the overlay and br_netfilter module is loaded
- path: /etc/modules-load.d/k8s.conf
  permissions: '0644'
  content: |
    overlay
    br_netfilter
#As a requirement for your Linux Node's iptables to correctly see bridged traffic, you should ensure net.bridge.bridge-nf-call-iptables is set to 1 in your sysctl config
- path: /etc/sysctl.d/k8s.conf
  permissions: '0644'
  content: |
    net.bridge.bridge-nf-call-ip6tables = 1
    net.bridge.bridge-nf-call-iptables  = 1
    net.ipv4.ip_forward                 = 1
%{ if node_type == "master" ~}
#Azure Cloud Controller Manager Configuration
- path: /etc/kubernetes/cloud.conf
  permissions: '0644'
  content: |
    {
        "cloud":"AzurePublicCloud",
        "tenantId": "${tenant_id}",
        "subscriptionId": "${subscription_id}",
        "resourceGroup": "${resource_group_name}",
        "location": "${location}",
        "vmType": "standard",
        "subnetName": "${subnet_name}",
        "securityGroupName": "${nsg_name}",
        "vnetName": "${vnet_name}",
        "vnetResourceGroup": "${vnet_resource_group_name}",
        "routeTableName": "${route_table_name}",
        "cloudProviderBackoff": true,
        "cloudProviderBackoffRetries": 6,
        "cloudProviderBackoffExponent": 1.5,
        "cloudProviderBackoffDuration": 5,
        "cloudProviderBackoffJitter": 1,
        "cloudProviderRatelimit": true,
        "cloudProviderRateLimitQPS": 3,
        "cloudProviderRateLimitBucket": 10,
        "useManagedIdentityExtension": true,
        "userAssignedIdentityID": "",
        "useInstanceMetadata": true,
        "loadBalancerSku": "Standard",
        "excludeMasterFromStandardLB": false,
        "providerVaultName": "",
        "maximumLoadBalancerRuleCount": 250,
        "providerKeyName": "k8s",
        "providerKeyVersion": ""
    }
#Azure CNI network config file
- path: /etc/cni/net.d/azure-cni.conf
  permissions: '0644'
  content: |
    {
        "cniVersion":"0.3.0",
        "name":"azure",
        "plugins":[
            {
                "type":"azure-vnet",
                "mode":"bridge",
                "bridge":"azure0",
                "ipam":{
                    "type":"azure-vnet-ipam"
                }
            },
            {
                "type":"portmap",
                "capabilities":{
                    "portMappings":true
                },
                "snat":true
            }
        ]
    }
#Install Azure CNI plugin
- path: /etc/kubeadm/install-cni-plugin.sh
  permissions: '0744'
  content: |
    #!/usr/bin/env bash

    # Installs azure-vnet CNI plugins on a Linux node.

    # Arguments.
    PLUGIN_VERSION=$1
    CNI_VERSION=$2
    CNI_BIN_DIR=/opt/cni/bin
    CNI_NETCONF_DIR=/etc/cni/net.d

    function usage
    {
        printf "Installs azure-vnet CNI plugins.\n"
        printf "Usage: install-cni-plugin version [cniVersion]\n"
    }

    if [ "$PLUGIN_VERSION" = "" ]; then
        usage
        exit 1
    fi

    if [ "$CNI_VERSION" = "" ]; then
        CNI_VERSION=v0.4.0
    fi

    # Create CNI directories.
    printf "Creating CNI directories.\n"
    mkdir -p $CNI_BIN_DIR
    mkdir -p $CNI_NETCONF_DIR

    # Install ebtables.
    if [ ! -e /sbin/ebtables ]
    then
        printf "Installing ebtables package..."
        apt-get update
        apt-get install -y ebtables
        printf "done.\n"
    else
        echo "Package ebtables is already installed."
    fi
    /sbin/ebtables --list > /dev/null

    # Install azure-vnet CNI plugins.
    printf "Installing azure-vnet CNI plugin version $PLUGIN_VERSION to $CNI_BIN_DIR..."
    /usr/bin/curl -sSL https://github.com/Azure/azure-container-networking/releases/download/$PLUGIN_VERSION/azure-vnet-cni-linux-amd64-$PLUGIN_VERSION.tgz > $CNI_BIN_DIR/azure-vnet.tgz
    tar -xzf $CNI_BIN_DIR/azure-vnet.tgz -C $CNI_BIN_DIR
    printf "done.\n"

    # Install azure-vnet CNI network configuration file.
    printf "Installing azure-vnet CNI network configuration file to $CNI_NETCONF_DIR..."
    mv $CNI_BIN_DIR/*.conflist $CNI_NETCONF_DIR
    printf "done.\n"

    # Install loopback plugin.
    printf "Installing loopback CNI plugin version $CNI_VERSION to $CNI_BIN_DIR..."
    /usr/bin/curl -sSL https://github.com/containernetworking/plugins/releases/download/$CNI_VERSION/cni-plugins-linux-amd64-$CNI_VERSION.tgz > $CNI_BIN_DIR/cni.tgz
    tar -xzf $CNI_BIN_DIR/cni.tgz -C $CNI_BIN_DIR ./loopback
    printf "done.\n"

    # Cleanup.
    rm $CNI_BIN_DIR/*.tgz
    chown root:root $CNI_BIN_DIR/*

    printf "azure-vnet CNI plugin is successfully installed.\n"
%{ endif ~}
runcmd:
#Set up dependencies
- [ modprobe, overlay ]
- [ modprobe, br_netfilter ]
- [ sysctl, --system ]
#Download Docker's official GPG key
- [ sh, -c, 'curl -s https://download.docker.com/linux/ubuntu/gpg | apt-key add -' ]
#Set up docker's stable repository
- [ sh, -c, 'echo deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable > /etc/apt/sources.list.d/docker.list' ]
#Download the Google Cloud public signing key
- [ sh, -c, 'curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -' ]
#Add the Kubernetes apt repository:
- [ sh, -c, 'echo deb https://apt.kubernetes.io/ kubernetes-xenial main > /etc/apt/sources.list.d/kubernetes.list' ]
- [ apt-get, update ]
#Install packages
- [ sh, -c, 'apt-get install -y -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" containerd.io' ]
- [ apt-get, install, -y, kubelet=1.20.4-00, kubeadm=1.20.4-00, kubectl=1.20.4-00 ]
- [ apt-mark, hold, kubelet, kubeadm, kubectl ]
#Install containerd as the container runtime
- [ mkdir, -p, /etc/containerd ]
- [ systemctl, restart, containerd ]
%{ if node_type == "master" ~}
#If this is a master node, grab the certs we need
- [ mkdir, -p, /etc/kubernetes/pki/etcd ]
- [ cp, /var/lib/waagent/${certificates["ca-kubernetes"]}.crt, /etc/kubernetes/pki/ca.crt ]
- [ cp, /var/lib/waagent/${certificates["ca-kubernetes"]}.prv, /etc/kubernetes/pki/ca.key ]
- [ cp, /var/lib/waagent/${certificates["ca-etcd"]}.crt, /etc/kubernetes/pki/etcd/ca.crt ]
- [ cp, /var/lib/waagent/${certificates["ca-etcd"]}.prv, /etc/kubernetes/pki/etcd/ca.key ]
- [ cp, /var/lib/waagent/${certificates["ca-kubernetes-front-proxy"]}.crt, /etc/kubernetes/pki/front-proxy-ca.crt ]
- [ cp, /var/lib/waagent/${certificates["ca-kubernetes-front-proxy"]}.prv, /etc/kubernetes/pki/front-proxy-ca.key ]
#Install Azure CNI plugin
- [ /etc/kubeadm/install-cni-plugin.sh, v1.2.7, v0.9.1 ]
#Initialize the cluster
- [ sh, -c, 'kubeadm init --config /etc/kubeadm/kubeadm-config.yml --v=10' ]
#- [ kubectl, apply, -f https://raw.githubusercontent.com/Azure/acs-engine/master/parts/k8s/addons/kubernetesmasteraddons-azure-npm-daemonset.yaml ]
- [ mkdir, -p, /home/${admin_username}/.kube ]
- [ cp, -i, /etc/kubernetes/admin.conf /home/${admin_username}/.kube/config ]
- [ chown, '${admin_username}:${admin_username}', /home/${admin_username}/.kube/config ]
%{ else ~}
#Join the worker to the cluster
- [ sh, -c, 'kubeadm join --config /etc/kubeadm/kubeadm-config.yml --v=10']
%{ endif ~}
#Set up rules to Source NAT anything not destined for the landing zone vnet CIDR
#- [ sh, -c, 'iptables -t nat -A POSTROUTING -m iprange ! --dst-range 168.63.129.16 -m addrtype ! --dst-type local ! -d ${vnet_cidr} -j MASQUERADE' ]
#sudo kubectl apply -f https://raw.githubusercontent.com/Azure/acs-engine/master/parts/k8s/addons/kubernetesmasteraddons-azure-npm-daemonset.yaml
